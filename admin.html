<script>
    // MAIN APPLICATION
    (function() {
        'use strict';
        
        // Configuration
        const SUPABASE_URL = 'https://faxjeniohetefqwcsefi.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_7TZ_Y-HKZc_ibl59lqyAsQ_Qbv9A2o7';
        
        // App State
        const state = {
            db: null,
            currentView: 'dashboard',
            selectedDate: null,
            currentMonth: new Date().getMonth(),
            currentYear: new Date().getFullYear(),
            weekOffset: 0,
            timeSlots: [],
            analyticsCharts: {
                traffic: null,
                sources: null,
                devices: null
            },
            defaultSettings: {
                startTime: '00:00',
                endTime: '23:59',
                slotDuration: 60,
                workingDays: [0, 1, 2, 3, 4, 5, 6],
                leadTimeHours: 24,
                minBookingHours: 24,
                slotsPerDay: 24,
                is247Mode: true
            },
            isMobile: window.innerWidth <= 767,
            sidebarOpen: false,
            analyticsDateRange: '7days',
            activeUsersInterval: null
        };
        
        // Initialize
        function init() {
            try {
                // Initialize Supabase
                if (typeof supabase !== 'undefined') {
                    state.db = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                    console.log('Supabase connected successfully');
                } else {
                    throw new Error('Supabase SDK not loaded');
                }
                
                // Load default settings from localStorage
                loadDefaultSettings();
                
                // Setup event listeners
                setupEventListeners();
                
                // Initial load
                showSection('dashboard');
                loadDashboard();
                
                // Check database setup
                setTimeout(() => checkDatabaseSetup(), 1000);
                
                // Initialize SQL content
                initSqlContent();
                
                // Set default dates for bulk modal
                setDefaultBulkDates();
                
            } catch (error) {
                console.error('Initialization error:', error);
                showNotification('Error initializing application', 'error');
            }
        }
        
        // Initialize SQL content
        function initSqlContent() {
            const createTableSql = `-- Create all analytics tables
CREATE TABLE IF NOT EXISTS analytics_active_users (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    session_id text NOT NULL UNIQUE,
    user_id text,
    page_url text,
    last_activity timestamp without time zone DEFAULT now(),
    active_duration integer DEFAULT 0,
    is_mobile boolean DEFAULT false,
    city text,
    current_action text,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT analytics_active_users_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS analytics_conversions (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    session_id text NOT NULL,
    conversion_type text NOT NULL,
    conversion_value numeric,
    booking_id bigint,
    customer_email text,
    customer_phone text,
    service_type text,
    estimated_value numeric,
    funnel_stage text,
    utm_source text,
    utm_medium text,
    utm_campaign text,
    days_to_convert integer,
    pageviews_to_convert integer,
    metadata jsonb,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT analytics_conversions_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS analytics_daily_stats (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    date date NOT NULL UNIQUE,
    total_sessions integer DEFAULT 0,
    total_visitors integer DEFAULT 0,
    new_visitors integer DEFAULT 0,
    returning_visitors integer DEFAULT 0,
    total_pageviews integer DEFAULT 0,
    unique_pageviews integer DEFAULT 0,
    avg_session_duration integer DEFAULT 0,
    bounce_rate numeric DEFAULT 0,
    total_conversions integer DEFAULT 0,
    booking_conversions integer DEFAULT 0,
    quote_conversions integer DEFAULT 0,
    contact_conversions integer DEFAULT 0,
    conversion_rate numeric DEFAULT 0,
    organic_search integer DEFAULT 0,
    direct_traffic integer DEFAULT 0,
    social_media integer DEFAULT 0,
    referral_traffic integer DEFAULT 0,
    email_campaigns integer DEFAULT 0,
    mobile_users integer DEFAULT 0,
    desktop_users integer DEFAULT 0,
    tablet_users integer DEFAULT 0,
    london_visitors integer DEFAULT 0,
    kent_visitors integer DEFAULT 0,
    essex_visitors integer DEFAULT 0,
    other_visitors integer DEFAULT 0,
    popular_pages jsonb DEFAULT '[]'::jsonb,
    revenue_generated numeric DEFAULT 0,
    avg_order_value numeric DEFAULT 0,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    CONSTRAINT analytics_daily_stats_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS analytics_events (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    session_id text NOT NULL,
    event_type text NOT NULL,
    event_category text,
    event_label text,
    event_value text,
    element_id text,
    element_class text,
    element_text text,
    page_url text,
    metadata jsonb,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT analytics_events_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS analytics_pageviews (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    session_id text NOT NULL,
    page_url text NOT NULL,
    page_title text,
    page_path text,
    referrer text,
    time_on_page integer,
    scroll_depth integer,
    is_bounce boolean DEFAULT true,
    previous_page text,
    next_page text,
    metadata jsonb,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT analytics_pageviews_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS analytics_search_terms (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    search_term text NOT NULL,
    postcode_area text,
    is_in_coverage_area boolean,
    result_type text,
    search_count integer DEFAULT 1,
    last_searched_at timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT analytics_search_terms_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS analytics_sessions (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    session_id text NOT NULL UNIQUE,
    user_id text,
    device_type text,
    browser text,
    browser_version text,
    os text,
    os_version text,
    screen_resolution text,
    language text,
    timezone text,
    ip_address text,
    country text,
    region text,
    city text,
    postal_code text,
    latitude numeric,
    longitude numeric,
    is_first_visit boolean DEFAULT true,
    utm_source text,
    utm_medium text,
    utm_campaign text,
    utm_term text,
    utm_content text,
    referrer text,
    landing_page text,
    entry_timestamp timestamp without time zone DEFAULT now(),
    exit_timestamp timestamp without time zone,
    session_duration integer,
    pageviews_count integer DEFAULT 0,
    is_converted boolean DEFAULT false,
    conversion_type text,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT analytics_sessions_pkey PRIMARY KEY (id)
);

-- Create bookings and availability tables
CREATE TABLE IF NOT EXISTS bookings (
    id BIGSERIAL PRIMARY KEY,
    booking_reference TEXT UNIQUE DEFAULT 'GG' || LPAD(CAST(nextval('bookings_id_seq') AS TEXT), 6, '0'),
    customer_name TEXT NOT NULL,
    customer_email TEXT,
    customer_phone TEXT,
    customer_address TEXT,
    booking_date DATE NOT NULL,
    time_slot TEXT NOT NULL,
    service_title TEXT,
    status TEXT DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW(),
    duration INTEGER DEFAULT 60,
    notes TEXT,
    price DECIMAL(10,2)
);

CREATE TABLE IF NOT EXISTS availability_slots (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slot_date DATE NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    is_blocked BOOLEAN DEFAULT false,
    booked_count INTEGER DEFAULT 0,
    max_capacity INTEGER DEFAULT 1,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(slot_date, start_time, end_time)
);

-- Create indexes for faster queries
CREATE INDEX IF NOT EXISTS idx_availability_slots_date ON availability_slots(slot_date);
CREATE INDEX IF NOT EXISTS idx_bookings_date ON bookings(booking_date);
CREATE INDEX IF NOT EXISTS idx_analytics_sessions_date ON analytics_sessions(created_at);
CREATE INDEX IF NOT EXISTS idx_analytics_conversions_date ON analytics_conversions(created_at);
CREATE INDEX IF NOT EXISTS idx_analytics_active_users_time ON analytics_active_users(last_activity);`;
            
            document.getElementById('createTableSql').value = createTableSql;
        }
        
        // Set default dates for bulk modal
        function setDefaultBulkDates() {
            const today = new Date();
            const startDate = new Date(today);
            startDate.setDate(today.getDate() + 2);
            
            const endDate = new Date(today);
            endDate.setDate(today.getDate() + 30);
            
            document.getElementById('bulkStartDate').value = startDate.toISOString().split('T')[0];
            document.getElementById('bulkEndDate').value = endDate.toISOString().split('T')[0];
        }
        
        // Toggle sidebar
        function toggleSidebar() {
            const sidebar = document.querySelector('.admin-sidebar');
            state.sidebarOpen = !state.sidebarOpen;
            
            if (state.sidebarOpen) {
                sidebar.classList.remove('closed');
                sidebar.classList.add('active');
            } else {
                sidebar.classList.remove('active');
                sidebar.classList.add('closed');
            }
        }
        
        // Close sidebar on mobile
        function closeSidebar() {
            if (state.isMobile) {
                const sidebar = document.querySelector('.admin-sidebar');
                sidebar.classList.remove('active');
                sidebar.classList.add('closed');
                state.sidebarOpen = false;
            }
        }
        
        // Database setup check
        async function checkDatabaseSetup() {
            try {
                console.log('Checking database setup...');
                const { data, error } = await state.db
                    .from('bookings')
                    .select('*')
                    .limit(1);
                
                console.log('Database check result:', { data, error });
                
                if (error && error.message.includes('does not exist')) {
                    showNotification('Database tables need to be created', 'warning');
                    return false;
                }
                
                if (!error && data) {
                    console.log('Database tables exist');
                    return true;
                }
            } catch (err) {
                console.warn('Database check failed:', err);
                return false;
            }
        }
        
        // Event Listeners
        function setupEventListeners() {
            // Mobile menu toggle
            document.getElementById('mobileMenuToggle').addEventListener('click', toggleSidebar);
            
            // Close sidebar button
            document.querySelector('.sidebar-close')?.addEventListener('click', closeSidebar);
            
            // Mobile bottom navigation
            document.querySelectorAll('.mobile-bottom-nav-item').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    const section = this.getAttribute('data-section');
                    
                    if (section === 'dashboard') {
                        showSection('dashboard');
                    } else if (section === 'calendar') {
                        showSection('calendar');
                    } else if (section === 'bookings') {
                        showSection('bookings');
                    } else if (section === 'analytics') {
                        showSection('analytics');
                    }
                    
                    // Update active state
                    document.querySelectorAll('.mobile-bottom-nav-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    this.classList.add('active');
                });
            });
            
            // Navigation
            document.querySelectorAll('.admin-nav-link').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const section = this.getAttribute('data-section');
                    if (section === 'databaseSetupBtn') {
                        openDatabaseSetupModal();
                    } else if (section === 'bulkSetupBtn') {
                        openBulkSetupModal();
                    } else {
                        showSection(section);
                    }
                    closeSidebar();
                });
            });
            
            // Database setup modal
            document.getElementById('databaseSetupBtn').addEventListener('click', openDatabaseSetupModal);
            document.getElementById('closeDatabaseSetupModal').addEventListener('click', closeDatabaseSetupModal);
            document.getElementById('mobileDatabaseBtn').addEventListener('click', openDatabaseSetupModal);
            
            // Bulk setup modal
            document.getElementById('bulkSetupBtn').addEventListener('click', openBulkSetupModal);
            document.getElementById('closeBulkSetupModal').addEventListener('click', closeBulkSetupModal);
            
            // Dashboard
            document.getElementById('refreshDashboardBtn').addEventListener('click', loadDashboard);
            document.getElementById('prevWeekBtn').addEventListener('click', prevWeek);
            document.getElementById('nextWeekBtn').addEventListener('click', nextWeek);
            document.getElementById('saveQuickChangesBtn').addEventListener('click', saveQuickChanges);
            document.getElementById('goToFullCalendarBtn').addEventListener('click', goToFullCalendar);
            document.getElementById('apply247WeekQuickBtn').addEventListener('click', () => apply247ToWeek());
            
            // Calendar
            document.getElementById('todayBtn').addEventListener('click', goToToday);
            document.getElementById('refreshCalendarBtn').addEventListener('click', loadCalendar);
            document.getElementById('prevMonthBtn').addEventListener('click', prevMonth);
            document.getElementById('nextMonthBtn').addEventListener('click', nextMonth);
            document.getElementById('saveTimeSlotsBtn').addEventListener('click', saveTimeSlots);
            document.getElementById('selectAllBtn').addEventListener('click', selectAllSlots);
            document.getElementById('deselectAllBtn').addEventListener('click', deselectAllSlots);
            document.getElementById('blockDayBtn').addEventListener('click', blockDay);
            document.getElementById('apply247MonthBtn').addEventListener('click', () => apply247ToMonth());
            document.getElementById('apply247DayBtn').addEventListener('click', apply247ToSelectedDay);
            
            // Bookings
            document.getElementById('refreshBookingsBtn').addEventListener('click', loadBookings);
            
            // Analytics
            document.getElementById('refreshAnalyticsBtn').addEventListener('click', loadAnalytics);
            document.getElementById('exportAnalyticsBtn').addEventListener('click', exportAnalytics);
            document.getElementById('analyticsDateRange').addEventListener('change', handleDateRangeChange);
            document.getElementById('applyCustomRange').addEventListener('click', applyCustomDateRange);
            document.getElementById('cancelCustomRange').addEventListener('click', cancelCustomDateRange);
            document.getElementById('refreshSessions').addEventListener('click', loadSessions);
            document.getElementById('refreshConversions').addEventListener('click', loadRecentConversions);
            
            // Export buttons
            document.getElementById('exportSessionsBtn').addEventListener('click', () => exportData('sessions'));
            document.getElementById('exportConversionsBtn').addEventListener('click', () => exportData('conversions'));
            document.getElementById('exportPageviewsBtn').addEventListener('click', () => exportData('pageviews'));
            document.getElementById('exportSearchTermsBtn').addEventListener('click', () => exportData('search_terms'));
            
            // Chart navigation
            document.querySelectorAll('[data-chart]').forEach(btn => {
                btn.addEventListener('click', function() {
                    const chartType = this.dataset.chart;
                    updateChartType(chartType);
                });
            });
            
            // Booking details modal
            document.getElementById('closeBookingDetailsModal').addEventListener('click', closeBookingDetailsModal);
            document.getElementById('closeBookingDetailsBtn').addEventListener('click', closeBookingDetailsModal);
            document.getElementById('printBookingBtn').addEventListener('click', printBookingDetails);
            document.getElementById('bookingDetailsModal').addEventListener('click', function(e) {
                if (e.target === this) closeBookingDetailsModal();
            });
            
            // Bulk setup modal buttons
            document.getElementById('apply247WeekBtnModal').addEventListener('click', () => {
                setBulkDateRange('week');
            });
            document.getElementById('apply247MonthBtnModal').addEventListener('click', () => {
                setBulkDateRange('month');
            });
            document.getElementById('apply247YearBtnModal').addEventListener('click', () => {
                setBulkDateRange('year');
            });
            
            // Modal backdrop clicks
            document.getElementById('databaseSetupModal').addEventListener('click', function(e) {
                if (e.target === this) closeDatabaseSetupModal();
            });
            
            document.getElementById('bookingDetailsModal').addEventListener('click', function(e) {
                if (e.target === this) closeBookingDetailsModal();
            });
            
            document.getElementById('bulkSetupModal').addEventListener('click', function(e) {
                if (e.target === this) closeBulkSetupModal();
            });
            
            // Window resize
            window.addEventListener('resize', handleResize);
            
            // Touch gestures for calendar navigation
            setupTouchGestures();
        }
        
        // Handle window resize
        function handleResize() {
            state.isMobile = window.innerWidth <= 767;
            
            if (!state.isMobile) {
                // On desktop, ensure sidebar is visible
                const sidebar = document.querySelector('.admin-sidebar');
                sidebar.classList.remove('closed');
                sidebar.classList.add('active');
                state.sidebarOpen = true;
            }
        }
        
        // Setup touch gestures
        function setupTouchGestures() {
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;
            
            const calendarGrid = document.querySelector('.main-calendar-grid');
            if (calendarGrid) {
                calendarGrid.addEventListener('touchstart', function(e) {
                    touchStartX = e.changedTouches[0].screenX;
                    touchStartY = e.changedTouches[0].screenY;
                }, { passive: true });
                
                calendarGrid.addEventListener('touchend', function(e) {
                    touchEndX = e.changedTouches[0].screenX;
                    touchEndY = e.changedTouches[0].screenY;
                    handleSwipe();
                }, { passive: true });
            }
            
            function handleSwipe() {
                const minSwipeDistance = 50;
                const xDiff = touchStartX - touchEndX;
                const yDiff = touchStartY - touchEndY;
                
                // Only consider horizontal swipes
                if (Math.abs(xDiff) > Math.abs(yDiff) && Math.abs(xDiff) > minSwipeDistance) {
                    if (xDiff > 0) {
                        // Swipe left - next month
                        nextMonth();
                    } else {
                        // Swipe right - previous month
                        prevMonth();
                    }
                }
            }
        }
        
        // Modal Functions
        function openDatabaseSetupModal() {
            document.getElementById('databaseSetupModal').style.display = 'flex';
            closeSidebar();
        }
        
        function closeDatabaseSetupModal() {
            document.getElementById('databaseSetupModal').style.display = 'none';
        }
        
        function openBulkSetupModal() {
            document.getElementById('bulkSetupModal').style.display = 'flex';
            closeSidebar();
        }
        
        function closeBulkSetupModal() {
            document.getElementById('bulkSetupModal').style.display = 'none';
        }
        
        function openBookingDetailsModal() {
            document.getElementById('bookingDetailsModal').style.display = 'flex';
        }
        
        function closeBookingDetailsModal() {
            document.getElementById('bookingDetailsModal').style.display = 'none';
        }
        
        function printBookingDetails() {
            const content = document.getElementById('bookingDetailsContent').innerHTML;
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <html>
                <head>
                    <title>Booking Details</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        .print-header { text-align: center; margin-bottom: 30px; }
                        .print-header h1 { color: #065F46; }
                        .detail-section { margin-bottom: 20px; }
                        .detail-label { font-weight: bold; color: #666; margin-bottom: 5px; }
                        .detail-value { margin-bottom: 15px; }
                        @media print {
                            .no-print { display: none; }
                        }
                    </style>
                </head>
                <body>
                    <div class="print-header">
                        <h1>GreenGlo 24/7 Booking Details</h1>
                        <p>Printed on ${new Date().toLocaleDateString()}</p>
                    </div>
                    ${content}
                    <div class="no-print" style="margin-top: 30px; text-align: center;">
                        <button onclick="window.print()" style="padding: 10px 20px; background: #10B981; color: white; border: none; border-radius: 5px; cursor: pointer;">Print</button>
                        <button onclick="window.close()" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">Close</button>
                    </div>
                </body>
                </html>
            `);
            printWindow.document.close();
        }
        
        // Set bulk date range
        function setBulkDateRange(rangeType) {
            const today = new Date();
            const startDate = new Date(today);
            const endDate = new Date(today);
            
            switch(rangeType) {
                case 'week':
                    startDate.setDate(today.getDate() + 2);
                    endDate.setDate(today.getDate() + 8);
                    break;
                case 'month':
                    startDate.setDate(today.getDate() + 2);
                    endDate.setMonth(today.getMonth() + 1);
                    endDate.setDate(0);
                    break;
                case 'year':
                    startDate.setDate(today.getDate() + 2);
                    endDate.setFullYear(today.getFullYear() + 1);
                    endDate.setDate(0);
                    break;
            }
            
            document.getElementById('bulkStartDate').value = startDate.toISOString().split('T')[0];
            document.getElementById('bulkEndDate').value = endDate.toISOString().split('T')[0];
        }
        
        // Apply 24/7 bulk settings
        async function apply247Bulk() {
            const startDate = document.getElementById('bulkStartDate').value;
            const endDate = document.getElementById('bulkEndDate').value;
            const leadTime = parseInt(document.getElementById('leadTimeHours').value) || 24;
            const startTime = document.getElementById('bulkStartTime').value || '00:00';
            const endTime = document.getElementById('bulkEndTime').value || '23:59';
            const slotDuration = parseInt(document.getElementById('bulkSlotDuration').value) || 60;
            
            // Update state settings
            state.defaultSettings.leadTimeHours = Math.max(24, leadTime);
            state.defaultSettings.minBookingHours = Math.max(24, leadTime);
            state.defaultSettings.startTime = startTime;
            state.defaultSettings.endTime = endTime;
            state.defaultSettings.slotDuration = slotDuration;
            
            // Save settings
            localStorage.setItem('greenglo_247_settings', JSON.stringify(state.defaultSettings));
            
            // Apply to date range
            await apply247AvailabilityRange(new Date(startDate), new Date(endDate));
            closeBulkSetupModal();
        }
        
        // Copy to clipboard helper
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            element.select();
            element.setSelectionRange(0, 99999);
            navigator.clipboard.writeText(element.value)
                .then(() => showNotification('SQL copied to clipboard!', 'success'))
                .catch(err => showNotification('Failed to copy: ' + err, 'error'));
        }
        
        // Notification System
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 4000);
        }
        
        // Settings functions
        function loadDefaultSettings() {
            const savedSettings = localStorage.getItem('greenglo_247_settings');
            if (savedSettings) {
                state.defaultSettings = JSON.parse(savedSettings);
            }
        }
        
        // Navigation
        function showSection(section) {
            // Update UI
            document.querySelectorAll('.admin-section').forEach(s => {
                s.style.display = 'none';
            });
            document.querySelectorAll('.admin-nav-link').forEach(link => {
                link.classList.remove('active');
            });
            document.querySelectorAll('.mobile-bottom-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show section
            document.getElementById(section + 'Section').style.display = 'block';
            const activeLink = document.querySelector(`.admin-nav-link[data-section="${section}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
            }
            
            // Update mobile bottom nav
            const mobileNavItem = document.querySelector(`.mobile-bottom-nav-item[data-section="${section}"]`);
            if (mobileNavItem) {
                mobileNavItem.classList.add('active');
            }
            
            state.currentView = section;
            
            // Load data
            switch(section) {
                case 'dashboard':
                    loadDashboard();
                    break;
                case 'calendar':
                    loadCalendar();
                    break;
                case 'bookings':
                    loadBookings();
                    break;
                case 'analytics':
                    loadAnalytics();
                    // Start active users polling
                    startActiveUsersPolling();
                    break;
            }
            
            // Close sidebar on mobile
            closeSidebar();
        }
        
        // Lead time validation
        function isWithinLeadTime(date) {
            const now = new Date();
            const bookingDate = new Date(date);
            const hoursDifference = (bookingDate - now) / (1000 * 60 * 60);
            
            return hoursDifference < state.defaultSettings.minBookingHours;
        }
        
        // DASHBOARD FUNCTIONS
        async function loadDashboard() {
            updateLastUpdated();
            await loadQuickCalendar();
            await updateDashboardStats();
        }
        
        function updateLastUpdated() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            document.getElementById('lastUpdatedTime').textContent = `Updated: ${timeStr}`;
        }
        
        async function loadQuickCalendar() {
            const container = document.getElementById('quickCalendarDays');
            if (!container) return;
            
            container.innerHTML = '';
            
            const today = new Date();
            const startOfWeek = new Date(today);
            startOfWeek.setDate(today.getDate() - today.getDay() + 1 + (state.weekOffset * 7));
            
            // Update week display
            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(startOfWeek.getDate() + 6);
            const startStr = startOfWeek.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const endStr = endOfWeek.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            document.getElementById('currentWeekDisplay').textContent = `${startStr} - ${endStr}`;
            
            // Create days
            for (let i = 0; i < 7; i++) {
                const day = new Date(startOfWeek);
                day.setDate(startOfWeek.getDate() + i);
                const dateStr = day.toISOString().split('T')[0];
                
                const dayElement = document.createElement('div');
                dayElement.className = 'week-day no-select';
                dayElement.dataset.date = dateStr;
                
                if (day.toDateString() === today.toDateString()) {
                    dayElement.classList.add('today');
                }
                
                // Check if within lead time
                if (isWithinLeadTime(dateStr)) {
                    dayElement.classList.add('within-lead-time');
                }
                
                // Day content
                dayElement.innerHTML = `
                    <div class="week-day-number">${day.getDate()}</div>
                    <div class="week-day-name">${day.toLocaleDateString('en-US', { weekday: 'short' })}</div>
                `;
                
                // Add status indicator
                const statusElement = document.createElement('div');
                statusElement.className = 'week-day-status';
                
                if (isWithinLeadTime(dateStr)) {
                    statusElement.textContent = 'Within Lead Time';
                    statusElement.style.background = 'rgba(59, 130, 246, 0.1)';
                    statusElement.style.color = 'var(--blue)';
                } else {
                    statusElement.textContent = '24/7 Available';
                    statusElement.style.background = 'rgba(16, 185, 129, 0.1)';
                    statusElement.style.color = 'var(--primary-green)';
                }
                
                dayElement.appendChild(statusElement);
                
                // Add day status badge
                const badge = document.createElement('div');
                badge.className = 'day-status-badge';
                badge.style.cssText = 'position: absolute; top: 5px; right: 5px; width: 6px; height: 6px; border-radius: 50%;';
                
                if (isWithinLeadTime(dateStr)) {
                    badge.classList.add('day-status-within-lead-time');
                } else {
                    badge.classList.add('day-status-available');
                }
                
                dayElement.appendChild(badge);
                
                // Click to view in main calendar
                dayElement.addEventListener('click', () => {
                    if (isWithinLeadTime(dateStr)) {
                        showNotification('This date is within the lead time period', 'warning');
                        return;
                    }
                    showSection('calendar');
                    goToDate(day);
                });
                
                container.appendChild(dayElement);
            }
        }
        
        function prevWeek() {
            state.weekOffset--;
            loadQuickCalendar();
        }
        
        function nextWeek() {
            state.weekOffset++;
            loadQuickCalendar();
        }
        
        async function saveQuickChanges() {
            showNotification('Weekly changes saved successfully!', 'success');
            await loadQuickCalendar();
        }
        
        function goToFullCalendar() {
            showSection('calendar');
            state.currentMonth = new Date().getMonth();
            state.currentYear = new Date().getFullYear();
            renderMonthCalendar();
        }
        
        async function updateDashboardStats() {
            try {
                const today = new Date().toISOString().split('T')[0];
                console.log('Loading dashboard stats for today:', today);
                
                // Get today's bookings
                const { data: bookings, error } = await state.db
                    .from('bookings')
                    .select('*')
                    .eq('booking_date', today);
                
                console.log('Bookings data:', { bookings, error });
                
                if (!error && bookings) {
                    document.getElementById('todayBookings').textContent = bookings.length;
                    
                    // Pending requests
                    const pending = bookings.filter(b => b.status === 'pending').length;
                    document.getElementById('pendingRequests').textContent = pending;
                } else if (error) {
                    console.error('Error loading bookings:', error);
                    document.getElementById('todayBookings').textContent = '0';
                    document.getElementById('pendingRequests').textContent = '0';
                }
                
                // Get available slots for next 7 days (excluding lead time)
                const startDate = new Date();
                startDate.setDate(startDate.getDate() + Math.ceil(state.defaultSettings.minBookingHours / 24));
                const endDate = new Date();
                endDate.setDate(endDate.getDate() + 7);
                
                const startStr = startDate.toISOString().split('T')[0];
                const endStr = endDate.toISOString().split('T')[0];
                
                console.log('Loading availability slots from', startStr, 'to', endStr);
                
                const { data: availability, error: availError } = await state.db
                    .from('availability_slots')
                    .select('*')
                    .gte('slot_date', startStr)
                    .lte('slot_date', endStr)
                    .eq('is_blocked', false);
                
                console.log('Availability data:', { availability, availError });
                
                if (!availError && availability) {
                    document.getElementById('availableSlots').textContent = availability.length;
                    
                    // Count unique available days
                    const uniqueDays = [...new Set(availability.map(a => a.slot_date))];
                    document.getElementById('upcomingSlots').textContent = uniqueDays.length;
                } else if (availError) {
                    console.error('Error loading availability:', availError);
                    document.getElementById('availableSlots').textContent = '0';
                    document.getElementById('upcomingSlots').textContent = '0';
                }
                
            } catch (err) {
                console.error('Error updating stats:', err);
                showNotification('Error loading dashboard data: ' + err.message, 'error');
            }
        }
        
        // 24/7 Availability Functions
        async function apply247ToWeek() {
            const today = new Date();
            const startDate = new Date(today);
            startDate.setDate(today.getDate() + Math.ceil(state.defaultSettings.minBookingHours / 24));
            const endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + 6);
            
            if (confirm('Apply 24/7 availability to the next week (excluding lead time)?')) {
                await apply247AvailabilityRange(startDate, endDate);
                await loadQuickCalendar();
                showNotification('24/7 availability applied to next week!', 'success');
            }
        }
        
        async function apply247ToMonth() {
            const today = new Date();
            const startDate = new Date(today);
            startDate.setDate(today.getDate() + Math.ceil(state.defaultSettings.minBookingHours / 24));
            const endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0);
            
            if (confirm('Apply 24/7 availability to the next month (excluding lead time)?')) {
                await apply247AvailabilityRange(startDate, endDate);
                await loadCalendar();
                showNotification('24/7 availability applied to next month!', 'success');
            }
        }
        
        async function apply247ToSelectedDay() {
            if (!state.selectedDate) {
                showNotification('Please select a date first', 'warning');
                return;
            }
            
            if (isWithinLeadTime(state.selectedDate)) {
                showNotification('Cannot apply 24/7 to dates within lead time', 'warning');
                return;
            }
            
            if (confirm(`Apply 24/7 availability to ${state.selectedDate.toLocaleDateString()}?`)) {
                await apply247Availability(state.selectedDate);
                await loadTimeSlots(state.selectedDate);
                await renderMonthCalendar();
                showNotification('24/7 availability applied!', 'success');
            }
        }
        
        // CALENDAR FUNCTIONS
        function loadCalendar() {
            renderMonthCalendar();
            updateSelectedDateDisplay();
        }
        
        function goToToday() {
            const today = new Date();
            state.currentMonth = today.getMonth();
            state.currentYear = today.getFullYear();
            renderMonthCalendar();
            selectDate(today);
        }
        
        function prevMonth() {
            state.currentMonth--;
            if (state.currentMonth < 0) {
                state.currentMonth = 11;
                state.currentYear--;
            }
            renderMonthCalendar();
        }
        
        function nextMonth() {
            state.currentMonth++;
            if (state.currentMonth > 11) {
                state.currentMonth = 0;
                state.currentYear++;
            }
            renderMonthCalendar();
        }
        
        async function renderMonthCalendar() {
            const container = document.getElementById('monthCalendarDays');
            if (!container) return;
            
            container.innerHTML = '';
            
            const firstDay = new Date(state.currentYear, state.currentMonth, 1);
            const lastDay = new Date(state.currentYear, state.currentMonth + 1, 0);
            const today = new Date();
            
            // Update month display
            document.getElementById('currentMonthDisplay').textContent = 
                firstDay.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            
            // Get availability data for the month
            const startDate = new Date(state.currentYear, state.currentMonth, 1);
            const endDate = new Date(state.currentYear, state.currentMonth + 1, 0);
            
            const startStr = startDate.toISOString().split('T')[0];
            const endStr = endDate.toISOString().split('T')[0];
            
            console.log('Loading calendar availability from', startStr, 'to', endStr);
            
            let availabilityData = [];
            try {
                const { data, error } = await state.db
                    .from('availability_slots')
                    .select('*')
                    .gte('slot_date', startStr)
                    .lte('slot_date', endStr);
                
                console.log('Calendar availability data:', { data, error });
                
                if (!error && data) {
                    availabilityData = data;
                } else if (error) {
                    console.error('Error fetching availability:', error);
                }
            } catch (err) {
                console.error('Error fetching availability:', err);
            }
            
            // Group availability by date
            const availabilityByDate = {};
            availabilityData.forEach(slot => {
                if (!availabilityByDate[slot.slot_date]) {
                    availabilityByDate[slot.slot_date] = [];
                }
                availabilityByDate[slot.slot_date].push(slot);
            });
            
            // Add empty cells for days before the first day
            let firstDayIndex = firstDay.getDay();
            for (let i = 0; i < firstDayIndex; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'month-day other-month';
                emptyDay.style.opacity = '0.3';
                container.appendChild(emptyDay);
            }
            
            // Add days of the month
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const date = new Date(state.currentYear, state.currentMonth, day);
                const dateStr = date.toISOString().split('T')[0];
                const dayElement = document.createElement('div');
                dayElement.className = 'month-day no-select';
                dayElement.dataset.date = dateStr;
                
                if (date.toDateString() === today.toDateString()) {
                    dayElement.classList.add('today');
                }
                
                if (state.selectedDate && date.toDateString() === state.selectedDate.toDateString()) {
                    dayElement.classList.add('selected');
                }
                
                // Check if within lead time
                if (isWithinLeadTime(dateStr)) {
                    dayElement.classList.add('within-lead-time');
                }
                
                // Determine day status
                const dayAvailability = availabilityByDate[dateStr] || [];
                let availableSlots = 0;
                let blockedSlots = 0;
                
                dayAvailability.forEach(slot => {
                    if (slot.is_blocked || slot.booked_count >= slot.max_capacity) {
                        blockedSlots++;
                    } else {
                        availableSlots++;
                    }
                });
                
                // If no data, generate default 24/7 status
                if (dayAvailability.length === 0 && !isWithinLeadTime(dateStr)) {
                    availableSlots = state.defaultSettings.slotsPerDay;
                }
                
                // Day content
                dayElement.innerHTML = `
                    <div class="month-day-number">${day}</div>
                    <div class="month-day-events">
                        ${availableSlots > 0 ? '<div class="event-dot available"></div>' : ''}
                        ${blockedSlots > 0 ? '<div class="event-dot blocked"></div>' : ''}
                        ${isWithinLeadTime(dateStr) ? '<div class="event-dot available"></div><div class="event-dot blocked"></div>' : ''}
                    </div>
                `;
                
                // Add status badge
                const badge = document.createElement('div');
                badge.className = 'day-status-badge';
                badge.style.cssText = 'position: absolute; top: 5px; right: 5px; width: 6px; height: 6px; border-radius: 50%;';
                
                if (isWithinLeadTime(dateStr)) {
                    badge.classList.add('day-status-within-lead-time');
                } else if (availableSlots > 0 && blockedSlots === 0) {
                    badge.classList.add('day-status-available');
                } else if (availableSlots > 0 && blockedSlots > 0) {
                    badge.classList.add('day-status-partial');
                } else {
                    badge.classList.add('day-status-blocked');
                }
                
                dayElement.appendChild(badge);
                
                // Click handler
                dayElement.addEventListener('click', () => {
                    if (isWithinLeadTime(dateStr)) {
                        showNotification('This date is within the lead time period', 'warning');
                        return;
                    }
                    selectDate(date);
                });
                
                container.appendChild(dayElement);
            }
        }
        
        async function selectDate(date) {
            state.selectedDate = date;
            
            // Update UI
            document.querySelectorAll('.month-day').forEach(day => {
                day.classList.remove('selected');
            });
            
            const dateStr = date.toISOString().split('T')[0];
            const dayElement = document.querySelector(`.month-day[data-date="${dateStr}"]`);
            if (dayElement) {
                dayElement.classList.add('selected');
            }
            
            updateSelectedDateDisplay();
            await loadTimeSlots(date);
        }
        
        function updateSelectedDateDisplay() {
            const element = document.getElementById('selectedDateDisplay');
            if (element && state.selectedDate) {
                element.textContent = state.selectedDate.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                });
            } else {
                element.textContent = 'No date selected';
            }
        }
        
        async function loadTimeSlots(date) {
            const container = document.getElementById('timeSlotsGrid');
            const loading = document.getElementById('timeSlotsLoading');
            
            if (!container) return;
            
            container.innerHTML = '';
            loading.style.display = 'block';
            
            const dateStr = date.toISOString().split('T')[0];
            console.log('Loading time slots for date:', dateStr);
            
            // Check lead time
            if (isWithinLeadTime(dateStr)) {
                loading.style.display = 'none';
                container.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: var(--orange); grid-column: 1 / -1;">
                        <i class="fas fa-clock" style="font-size: 40px; margin-bottom: 15px;"></i>
                        <div style="font-size: 16px; margin-bottom: 10px;">Within Lead Time Period</div>
                        <div style="margin-bottom: 15px; font-size: 14px;">
                            Bookings for ${dateStr} must be made at least ${state.defaultSettings.minBookingHours} hours in advance.
                        </div>
                        <div style="font-size: 12px; color: var(--medium-gray);">
                            This date cannot be booked yet.
                        </div>
                    </div>
                `;
                return;
            }
            
            try {
                const { data: existingSlots, error } = await state.db
                    .from('availability_slots')
                    .select('*')
                    .eq('slot_date', dateStr)
                    .order('start_time');
                
                console.log('Time slots data:', { existingSlots, error });
                
                if (error) {
                    if (error.message.includes('does not exist')) {
                        container.innerHTML = `
                            <div style="text-align: center; padding: 30px; color: var(--orange); grid-column: 1 / -1;">
                                <i class="fas fa-exclamation-triangle" style="font-size: 40px; margin-bottom: 15px;"></i>
                                <div style="font-size: 16px; margin-bottom: 10px;">Database Setup Required</div>
                                <div style="margin-bottom: 15px; font-size: 14px;">The 24/7 availability table needs to be created.</div>
                                <button onclick="openDatabaseSetupModal()" class="btn btn-warning">
                                    <i class="fas fa-database"></i>
                                    Open Database Setup
                                </button>
                            </div>
                        `;
                        return;
                    }
                    throw error;
                }
                
                loading.style.display = 'none';
                
                let slots = existingSlots;
                
                if (!slots || slots.length === 0) {
                    slots = generate247Slots(date);
                    console.log('Generated slots:', slots);
                }
                
                // Display slots
                if (slots && slots.length > 0) {
                    slots.forEach(slot => {
                        const startTime = slot.start_time ? slot.start_time.substring(0, 5) : '00:00';
                        const endTime = slot.end_time ? slot.end_time.substring(0, 5) : '01:00';
                        const timeSlot = `${startTime}-${endTime}`;
                        
                        const slotElement = document.createElement('div');
                        slotElement.className = `time-slot-card no-select`;
                        slotElement.dataset.slotId = slot.id || 'new';
                        slotElement.dataset.timeSlot = timeSlot;
                        
                        // Determine slot status
                        if (slot.booked_count >= slot.max_capacity) {
                            slotElement.classList.add('booked');
                            slotElement.dataset.isAvailable = 'false';
                        } else if (slot.is_blocked) {
                            slotElement.classList.add('blocked');
                            slotElement.dataset.isAvailable = 'false';
                        } else {
                            slotElement.classList.add('selected');
                            slotElement.dataset.isAvailable = 'true';
                        }
                        
                        slotElement.innerHTML = `
                            <div class="time-slot-time">${formatTime(startTime)} - ${formatTime(endTime)}</div>
                            <div class="time-slot-status ${slot.booked_count >= slot.max_capacity ? 'slot-booked' : slot.is_blocked ? 'slot-blocked' : 'slot-available'}">
                                ${slot.booked_count >= slot.max_capacity ? 'Booked' : slot.is_blocked ? 'Blocked' : 'Available'}
                            </div>
                            ${slot.booked_count > 0 ? `<div style="font-size: 11px; margin-top: 3px; color: var(--medium-gray);">${slot.booked_count}/${slot.max_capacity} booked</div>` : ''}
                        `;
                        
                        // Toggle availability (only if not booked)
                        slotElement.addEventListener('click', function() {
                            if (this.classList.contains('booked')) {
                                showNotification('Cannot modify booked time slots', 'warning');
                                return;
                            }
                            
                            const isCurrentlyAvailable = this.classList.contains('selected');
                            const newStatus = !isCurrentlyAvailable;
                            
                            this.classList.toggle('selected', newStatus);
                            this.classList.toggle('blocked', !newStatus);
                            this.dataset.isAvailable = newStatus;
                            
                            const status = this.querySelector('.time-slot-status');
                            if (newStatus) {
                                status.textContent = 'Available';
                                status.className = 'time-slot-status slot-available';
                            } else {
                                status.textContent = 'Blocked';
                                status.className = 'time-slot-status slot-blocked';
                            }
                        });
                        
                        container.appendChild(slotElement);
                    });
                } else {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 30px; color: var(--medium-gray); grid-column: 1 / -1;">
                            <i class="fas fa-calendar-alt" style="font-size: 40px; margin-bottom: 15px; opacity: 0.5;"></i>
                            <div>No time slots available for this date</div>
                        </div>
                    `;
                }
                
            } catch (err) {
                console.error('Error loading time slots:', err);
                loading.style.display = 'none';
                container.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: var(--red); grid-column: 1 / -1;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 40px; margin-bottom: 15px;"></i>
                        <div style="font-size: 14px;">Error loading time slots: ${err.message}</div>
                        <button onclick="loadTimeSlots(state.selectedDate)" class="btn btn-secondary" style="margin-top: 15px;">
                            <i class="fas fa-redo"></i>
                            Retry
                        </button>
                    </div>
                `;
            }
        }
        
        function generate247Slots(date) {
            const slots = [];
            
            // Generate 24-hour slots
            for (let i = 0; i < 24; i++) {
                const hour = i;
                const nextHour = (i + 1) % 24;
                
                const startTime = `${hour.toString().padStart(2, '0')}:00`;
                const endTime = `${nextHour.toString().padStart(2, '0')}:00`;
                
                slots.push({
                    id: null,
                    slot_date: date.toISOString().split('T')[0],
                    start_time: startTime + ':00',
                    end_time: endTime + ':00',
                    is_blocked: false,
                    booked_count: 0,
                    max_capacity: 1
                });
            }
            
            return slots;
        }
        
        function formatTime(time) {
            try {
                const [hour, minute] = time.split(':');
                const hourNum = parseInt(hour);
                const suffix = hourNum >= 12 ? 'PM' : 'AM';
                const displayHour = hourNum > 12 ? hourNum - 12 : (hourNum === 0 ? 12 : hourNum);
                return `${displayHour}:${minute || '00'} ${suffix}`;
            } catch (e) {
                return time;
            }
        }
        
        async function saveTimeSlots() {
            if (!state.selectedDate) {
                showNotification('Please select a date first', 'warning');
                return;
            }
            
            if (isWithinLeadTime(state.selectedDate)) {
                showNotification('Cannot save changes for dates within lead time', 'warning');
                return;
            }
            
            const container = document.getElementById('timeSlotsGrid');
            const slotElements = container.querySelectorAll('.time-slot-card');
            
            if (slotElements.length === 0) {
                showNotification('No time slots to save', 'warning');
                return;
            }
            
            const dateStr = state.selectedDate.toISOString().split('T')[0];
            const slotsToSave = [];
            
            slotElements.forEach(slotElement => {
                if (slotElement.classList.contains('booked')) return; // Skip booked slots
                
                const timeSlot = slotElement.dataset.timeSlot;
                const [startTime, endTime] = timeSlot.split('-');
                const isAvailable = slotElement.dataset.isAvailable === 'true';
                
                slotsToSave.push({
                    slot_date: dateStr,
                    start_time: startTime + ':00',
                    end_time: endTime + ':00',
                    is_blocked: !isAvailable,
                    booked_count: 0,
                    max_capacity: 1
                });
            });
            
            try {
                // First delete existing slots for this date
                const { error: deleteError } = await state.db
                    .from('availability_slots')
                    .delete()
                    .eq('slot_date', dateStr);
                
                if (deleteError) throw deleteError;
                
                // Insert new slots
                if (slotsToSave.length > 0) {
                    const { error: insertError } = await state.db
                        .from('availability_slots')
                        .insert(slotsToSave);
                    
                    if (insertError) throw insertError;
                }
                
                showNotification('24/7 time slots saved successfully!', 'success');
                
                await renderMonthCalendar();
                await loadTimeSlots(state.selectedDate);
                
            } catch (err) {
                console.error('Error saving time slots:', err);
                showNotification('Error saving time slots: ' + err.message, 'error');
            }
        }
        
        async function apply247Availability(date) {
            const dateStr = date.toISOString().split('T')[0];
            const slots = generate247Slots(date);
            
            try {
                // Delete existing slots
                const { error: deleteError } = await state.db
                    .from('availability_slots')
                    .delete()
                    .eq('slot_date', dateStr);
                
                if (deleteError) throw deleteError;
                
                // Insert 24/7 slots
                if (slots.length > 0) {
                    const { error: insertError } = await state.db
                        .from('availability_slots')
                        .insert(slots);
                    
                    if (insertError) throw insertError;
                }
                
            } catch (err) {
                console.error('Error applying 24/7 availability:', err);
                throw err;
            }
        }
        
        async function apply247AvailabilityRange(startDate, endDate) {
            const today = new Date();
            let successCount = 0;
            let skippedCount = 0;
            
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const dateStr = d.toISOString().split('T')[0];
                
                // Check lead time
                if (isWithinLeadTime(dateStr)) {
                    skippedCount++;
                    continue;
                }
                
                try {
                    await apply247Availability(d);
                    successCount++;
                } catch (err) {
                    console.error(`Error applying 24/7 availability for ${dateStr}:`, err);
                }
            }
            
            showNotification(`Applied 24/7 availability to ${successCount} days. ${skippedCount} days skipped (within lead time).`, 'success');
            
            // Refresh views
            if (state.currentView === 'dashboard') {
                await loadQuickCalendar();
            } else if (state.currentView === 'calendar') {
                await renderMonthCalendar();
                if (state.selectedDate) {
                    await loadTimeSlots(state.selectedDate);
                }
            }
        }
        
        function selectAllSlots() {
            document.querySelectorAll('.time-slot-card').forEach(slot => {
                if (slot.classList.contains('booked')) return;
                
                slot.classList.add('selected');
                slot.classList.remove('blocked');
                slot.dataset.isAvailable = 'true';
                
                const status = slot.querySelector('.time-slot-status');
                status.textContent = 'Available';
                status.className = 'time-slot-status slot-available';
            });
        }
        
        function deselectAllSlots() {
            document.querySelectorAll('.time-slot-card').forEach(slot => {
                if (slot.classList.contains('booked')) return;
                
                slot.classList.remove('selected');
                slot.classList.add('blocked');
                slot.dataset.isAvailable = 'false';
                
                const status = slot.querySelector('.time-slot-status');
                status.textContent = 'Blocked';
                status.className = 'time-slot-status slot-blocked';
            });
        }
        
        async function blockDay() {
            if (!state.selectedDate) {
                showNotification('Please select a date first', 'warning');
                return;
            }
            
            if (isWithinLeadTime(state.selectedDate)) {
                showNotification('Cannot block dates within lead time', 'warning');
                return;
            }
            
            if (confirm('Block all time slots for this day? This cannot be undone.')) {
                try {
                    const dateStr = state.selectedDate.toISOString().split('T')[0];
                    
                    const { error } = await state.db
                        .from('availability_slots')
                        .update({ is_blocked: true })
                        .eq('slot_date', dateStr);
                    
                    if (error) throw error;
                    
                    showNotification('Day blocked successfully!', 'success');
                    await loadTimeSlots(state.selectedDate);
                    await renderMonthCalendar();
                } catch (err) {
                    console.error('Error blocking day:', err);
                    showNotification('Error blocking day: ' + err.message, 'error');
                }
            }
        }
        
        function goToDate(date) {
            state.currentMonth = date.getMonth();
            state.currentYear = date.getFullYear();
            renderMonthCalendar();
            selectDate(date);
            
            // Scroll to calendar section on mobile
            if (state.isMobile) {
                document.getElementById('calendarSection').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        // BOOKINGS FUNCTIONS
        async function loadBookings() {
            const container = document.getElementById('bookingsList');
            if (!container) return;
            
            container.innerHTML = '<div class="loading"><div class="spinner"></div><div>Loading bookings...</div></div>';
            
            try {
                console.log('Loading bookings...');
                const { data: bookings, error } = await state.db
                    .from('bookings')
                    .select('*')
                    .order('booking_date', { ascending: false })
                    .limit(50);
                
                console.log('Bookings data:', { bookings, error });
                
                if (error) {
                    if (error.message.includes('does not exist')) {
                        container.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: var(--medium-gray);">
                                <i class="fas fa-calendar-check" style="font-size: 50px; margin-bottom: 15px; opacity: 0.5;"></i>
                                <h3 style="margin-bottom: 10px; font-size: 18px;">Bookings Table Setup Required</h3>
                                <p style="margin-bottom: 15px; font-size: 14px;">The bookings table needs to be set up.</p>
                                <button onclick="openDatabaseSetupModal()" class="btn btn-primary" style="margin: 10px;">
                                    <i class="fas fa-database"></i>
                                    Open Database Setup
                                </button>
                            </div>
                        `;
                        return;
                    }
                    throw error;
                }
                
                if (!bookings || bookings.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: var(--medium-gray);">
                            <i class="fas fa-calendar-check" style="font-size: 50px; margin-bottom: 15px; opacity: 0.5;"></i>
                            <h3 style="margin-bottom: 10px; font-size: 18px;">No Bookings Yet</h3>
                            <p style="font-size: 14px;">No bookings have been made yet</p>
                        </div>
                    `;
                    return;
                }
                
                // Group bookings by date
                const bookingsByDate = {};
                bookings.forEach(booking => {
                    const date = booking.booking_date || 'No Date';
                    if (!bookingsByDate[date]) {
                        bookingsByDate[date] = [];
                    }
                    bookingsByDate[date].push(booking);
                });
                
                let html = '<div style="display: flex; flex-direction: column; gap: 15px;">';
                
                // Add search and filter controls
                html += `
                    <div style="background: white; border-radius: var(--border-radius); box-shadow: var(--shadow); padding: 15px;">
                        <h3 style="color: var(--dark-green); margin-bottom: 10px; font-size: 16px;">Filters</h3>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-weight: 600; color: var(--dark-gray); font-size: 13px;">Search by name, email, or service</label>
                                <input type="text" id="bookingSearch" placeholder="Search..." style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 8px; font-family: 'Montserrat', sans-serif; font-size: 14px;">
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: var(--dark-gray); font-size: 13px;">Status</label>
                                    <select id="bookingStatusFilter" style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 8px; font-family: 'Montserrat', sans-serif; font-size: 14px;">
                                        <option value="all">All Status</option>
                                        <option value="pending">Pending</option>
                                        <option value="confirmed">Confirmed</option>
                                        <option value="cancelled">Cancelled</option>
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: var(--dark-gray); font-size: 13px;">Date Range</label>
                                    <select id="bookingDateFilter" style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 8px; font-family: 'Montserrat', sans-serif; font-size: 14px;">
                                        <option value="all">All Dates</option>
                                        <option value="today">Today</option>
                                        <option value="week">This Week</option>
                                        <option value="month">This Month</option>
                                    </select>
                                </div>
                            </div>
                            <div>
                                <button id="applyBookingFilters" class="btn btn-primary" style="width: 100%;">
                                    <i class="fas fa-filter"></i>
                                    Apply Filters
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                Object.keys(bookingsByDate).sort().reverse().forEach(date => {
                    const dateBookings = bookingsByDate[date];
                    const dateObj = new Date(date);
                    const dateStr = date !== 'No Date' ? dateObj.toLocaleDateString('en-US', {
                        weekday: 'short',
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    }) : 'No Date Specified';
                    
                    html += `
                        <div class="booking-date-group" style="background: white; border-radius: var(--border-radius); box-shadow: var(--shadow); overflow: hidden;">
                            <div style="background: var(--light-green); padding: 12px 15px; border-bottom: 1px solid #e5e7eb;">
                                <h3 style="color: var(--dark-green); margin: 0; font-size: 16px;">${dateStr}</h3>
                            </div>
                            <div style="padding: 15px;">
                                ${dateBookings.map(booking => `
                                    <div class="booking-card ${booking.status || 'pending'}">
                                        <div style="margin-bottom: 10px;">
                                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px; flex-wrap: wrap;">
                                                <div style="font-size: 16px; font-weight: 700; color: var(--dark-gray);">
                                                    ${booking.customer_name || 'Anonymous'}
                                                </div>
                                                <span style="padding: 4px 10px; border-radius: 20px; font-size: 11px; font-weight: 600; 
                                                    background: ${booking.status === 'confirmed' ? 'rgba(16, 185, 129, 0.1)' : 
                                                               booking.status === 'pending' ? 'rgba(245, 158, 11, 0.1)' : 
                                                               'rgba(239, 68, 68, 0.1)'}; 
                                                    color: ${booking.status === 'confirmed' ? 'var(--primary-green)' : 
                                                            booking.status === 'pending' ? 'var(--orange)' : 
                                                            'var(--red)'};">
                                                    ${booking.status || 'pending'}
                                                </span>
                                            </div>
                                            
                                            <div class="details-grid">
                                                ${booking.customer_email ? `
                                                    <div class="detail-item">
                                                        <div class="detail-label">Email</div>
                                                        <div class="detail-value" style="font-size: 13px;">
                                                            <i class="fas fa-envelope" style="margin-right: 5px; color: var(--primary-green); font-size: 12px;"></i>
                                                            ${booking.customer_email}
                                                        </div>
                                                    </div>
                                                ` : ''}
                                                
                                                ${booking.customer_phone ? `
                                                    <div class="detail-item">
                                                        <div class="detail-label">Phone</div>
                                                        <div class="detail-value" style="font-size: 13px;">
                                                            <i class="fas fa-phone" style="margin-right: 5px; color: var(--primary-green); font-size: 12px;"></i>
                                                            ${booking.customer_phone}
                                                        </div>
                                                    </div>
                                                ` : ''}
                                                
                                                ${booking.service_title ? `
                                                    <div class="detail-item">
                                                        <div class="detail-label">Service</div>
                                                        <div class="detail-value" style="font-size: 13px;">
                                                            <i class="fas fa-concierge-bell" style="margin-right: 5px; color: var(--primary-green); font-size: 12px;"></i>
                                                            ${booking.service_title}
                                                        </div>
                                                    </div>
                                                ` : ''}
                                                
                                                ${booking.time_slot ? `
                                                    <div class="detail-item">
                                                        <div class="detail-label">Time</div>
                                                        <div class="detail-value" style="font-size: 13px;">
                                                            <i class="fas fa-clock" style="margin-right: 5px; color: var(--primary-green); font-size: 12px;"></i>
                                                            ${booking.time_slot}
                                                        </div>
                                                    </div>
                                                ` : ''}
                                            </div>
                                        </div>
                                        
                                        <div style="display: flex; gap: 5px; justify-content: flex-end; margin-top: 10px;">
                                            <button class="btn btn-sm btn-success booking-action-btn" data-booking-id="${booking.id}" data-action="confirm" style="padding: 6px 10px; font-size: 12px;">
                                                <i class="fas fa-check"></i>
                                                <span style="font-size: 11px;">Confirm</span>
                                            </button>
                                            <button class="btn btn-sm btn-danger booking-action-btn" data-booking-id="${booking.id}" data-action="cancel" style="padding: 6px 10px; font-size: 12px;">
                                                <i class="fas fa-times"></i>
                                                <span style="font-size: 11px;">Cancel</span>
                                            </button>
                                            <button class="btn btn-sm btn-secondary booking-details-btn" data-booking-id="${booking.id}" style="padding: 6px 10px; font-size: 12px;">
                                                <i class="fas fa-eye"></i>
                                                <span style="font-size: 11px;">View</span>
                                            </button>
                                        </div>
                                        
                                        <div style="font-size: 11px; color: var(--medium-gray); margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0,0,0,0.05);">
                                            <i class="fas fa-calendar-plus" style="margin-right: 5px;"></i>
                                            Booked on ${new Date(booking.created_at).toLocaleDateString()} at ${new Date(booking.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                container.innerHTML = html;
                
                setupBookingEventListeners();
                
            } catch (err) {
                console.error('Error loading bookings:', err);
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--red);">
                        <i class="fas fa-exclamation-triangle" style="font-size: 50px; margin-bottom: 15px;"></i>
                        <h3 style="margin-bottom: 10px; font-size: 18px;">Error Loading Bookings</h3>
                        <p style="font-size: 14px;">${err.message}</p>
                        <button onclick="loadBookings()" class="btn btn-secondary" style="margin-top: 15px;">
                            <i class="fas fa-redo"></i>
                            Retry
                        </button>
                    </div>
                `;
            }
        }
        
        // Setup booking event listeners
        function setupBookingEventListeners() {
            const applyFiltersBtn = document.getElementById('applyBookingFilters');
            if (applyFiltersBtn) {
                applyFiltersBtn.addEventListener('click', applyBookingFilters);
            }
            
            document.querySelectorAll('.booking-action-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const bookingId = this.dataset.bookingId;
                    const action = this.dataset.action;
                    updateBookingStatus(bookingId, action);
                });
            });
            
            document.querySelectorAll('.booking-details-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const bookingId = this.dataset.bookingId;
                    showBookingDetails(bookingId);
                });
            });
        }
        
        // Filter bookings
        async function applyBookingFilters() {
            const searchTerm = document.getElementById('bookingSearch')?.value.toLowerCase() || '';
            const statusFilter = document.getElementById('bookingStatusFilter')?.value || 'all';
            const dateFilter = document.getElementById('bookingDateFilter')?.value || 'all';
            
            document.querySelectorAll('.booking-card').forEach(card => {
                card.style.display = 'none';
            });
            
            document.querySelectorAll('.booking-card').forEach(card => {
                const name = card.querySelector('div[style*="font-size: 16px"]')?.textContent.toLowerCase() || '';
                const emailElement = card.querySelector('div[style*="fas fa-envelope"]');
                const email = emailElement ? emailElement.parentElement.textContent.toLowerCase() : '';
                const serviceElement = card.querySelector('div[style*="fas fa-concierge-bell"]');
                const service = serviceElement ? serviceElement.parentElement.textContent.toLowerCase() : '';
                const status = card.querySelector('span[style*="padding: 4px 10px"]')?.textContent.toLowerCase() || '';
                const date = card.closest('.booking-date-group')?.querySelector('h3')?.textContent.toLowerCase() || '';
                
                let matchesSearch = !searchTerm || 
                    name.includes(searchTerm) || 
                    email.includes(searchTerm) || 
                    service.includes(searchTerm);
                
                let matchesStatus = statusFilter === 'all' || status === statusFilter;
                
                let matchesDate = true;
                if (dateFilter === 'today') {
                    const today = new Date().toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });
                    matchesDate = date.includes(today.split(',')[0]);
                } else if (dateFilter === 'week') {
                    const today = new Date();
                    const weekFromNow = new Date();
                    weekFromNow.setDate(today.getDate() + 7);
                    matchesDate = true;
                }
                
                if (matchesSearch && matchesStatus && matchesDate) {
                    card.style.display = 'block';
                    card.closest('.booking-date-group').style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
            
            document.querySelectorAll('.booking-date-group').forEach(group => {
                const visibleCards = group.querySelectorAll('.booking-card[style*="display: block"]').length;
                if (visibleCards === 0) {
                    group.style.display = 'none';
                } else {
                    group.style.display = 'block';
                }
            });
        }
        
        // Update booking status
        async function updateBookingStatus(bookingId, action) {
            const statusMap = {
                'confirm': 'confirmed',
                'cancel': 'cancelled'
            };
            
            const newStatus = statusMap[action];
            if (!newStatus) return;
            
            try {
                const { error } = await state.db
                    .from('bookings')
                    .update({ status: newStatus })
                    .eq('id', bookingId);
                
                if (error) throw error;
                
                showNotification(`Booking ${newStatus} successfully!`, 'success');
                await loadBookings();
                
            } catch (err) {
                console.error('Error updating booking:', err);
                showNotification('Error updating booking: ' + err.message, 'error');
            }
        }
        
        // Show booking details
        async function showBookingDetails(bookingId) {
            try {
                const { data: booking, error } = await state.db
                    .from('bookings')
                    .select('*')
                    .eq('id', bookingId)
                    .single();
                
                if (error) throw error;
                
                const detailsHtml = `
                    <div class="details-grid">
                        <div class="detail-item">
                            <div class="detail-label">Customer Name</div>
                            <div class="detail-value">${booking.customer_name || 'Not specified'}</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Email</div>
                            <div class="detail-value">${booking.customer_email || 'Not specified'}</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Phone</div>
                            <div class="detail-value">${booking.customer_phone || 'Not specified'}</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Address</div>
                            <div class="detail-value">${booking.customer_address || 'Not specified'}</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Service Title</div>
                            <div class="detail-value">${booking.service_title || 'Not specified'}</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Booking Date</div>
                            <div class="detail-value">${booking.booking_date ? new Date(booking.booking_date).toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' }) : 'Not specified'}</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Time Slot</div>
                            <div class="detail-value">${booking.time_slot || 'Not specified'}</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Duration</div>
                            <div class="detail-value">${booking.duration || 60} minutes</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Status</div>
                            <div class="detail-value">
                                <span style="padding: 4px 10px; border-radius: 20px; font-size: 12px; font-weight: 600; 
                                    background: ${booking.status === 'confirmed' ? 'rgba(16, 185, 129, 0.1)' : 
                                               booking.status === 'pending' ? 'rgba(245, 158, 11, 0.1)' : 
                                               'rgba(239, 68, 68, 0.1)'}; 
                                    color: ${booking.status === 'confirmed' ? 'var(--primary-green)' : 
                                            booking.status === 'pending' ? 'var(--orange)' : 
                                            'var(--red)'};">
                                    ${booking.status || 'pending'}
                                </span>
                            </div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-label">Booking Created</div>
                            <div class="detail-value">${new Date(booking.created_at).toLocaleString()}</div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: var(--light-green); border-radius: 8px;">
                        <div style="font-weight: 600; color: var(--dark-green); margin-bottom: 8px; font-size: 14px;">Quick Actions</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="updateBookingStatus(${booking.id}, 'confirm')" class="btn btn-success btn-sm" style="flex: 1;">
                                <i class="fas fa-check"></i> Confirm
                            </button>
                            <button onclick="updateBookingStatus(${booking.id}, 'cancel')" class="btn btn-danger btn-sm" style="flex: 1;">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                            ${booking.customer_email ? `
                                <a href="mailto:${booking.customer_email}" class="btn btn-primary btn-sm" style="flex: 1;">
                                    <i class="fas fa-envelope"></i> Email
                                </a>
                            ` : ''}
                            ${booking.customer_phone ? `
                                <a href="tel:${booking.customer_phone}" class="btn btn-secondary btn-sm" style="flex: 1;">
                                    <i class="fas fa-phone"></i> Call
                                </a>
                            ` : ''}
                        </div>
                    </div>
                `;
                
                document.getElementById('bookingDetailsContent').innerHTML = detailsHtml;
                openBookingDetailsModal();
                
            } catch (err) {
                console.error('Error loading booking details:', err);
                showNotification('Error loading booking details: ' + err.message, 'error');
            }
        }
        
        // ANALYTICS FUNCTIONS
        async function loadAnalytics() {
            try {
                console.log('Loading analytics data...');
                
                // Update UI to show loading state
                document.getElementById('totalVisitors').textContent = '0';
                document.getElementById('totalPageviews').textContent = '0';
                document.getElementById('totalConversions').textContent = '0';
                document.getElementById('conversionRate').textContent = '0%';
                document.getElementById('avgSessionDuration').textContent = '0s';
                document.getElementById('bounceRate').textContent = '0%';
                document.getElementById('revenueGenerated').textContent = '0';
                document.getElementById('avgOrderValue').textContent = '0';
                
                // Load all analytics data
                await loadAnalyticsStats();
                await loadTrafficChart();
                await loadSourcesChart();
                await loadDeviceChart();
                await loadActiveUsers();
                await loadSearchTerms();
                await loadSessions();
                await loadRecentConversions();
                await loadGeoData();
                
            } catch (err) {
                console.error('Error loading analytics:', err);
                showNotification('Error loading analytics data: ' + err.message, 'error');
            }
        }
        
        // Start active users polling
        function startActiveUsersPolling() {
            if (state.activeUsersInterval) {
                clearInterval(state.activeUsersInterval);
            }
            
            // Load immediately
            loadActiveUsers();
            
            // Poll every 30 seconds
            state.activeUsersInterval = setInterval(loadActiveUsers, 30000);
        }
        
        // Stop active users polling
        function stopActiveUsersPolling() {
            if (state.activeUsersInterval) {
                clearInterval(state.activeUsersInterval);
                state.activeUsersInterval = null;
            }
        }
        
        // Get date range based on selection
        function getDateRange() {
            const today = new Date();
            const startDate = new Date();
            
            switch(state.analyticsDateRange) {
                case 'today':
                    startDate.setDate(today.getDate());
                    break;
                case 'yesterday':
                    startDate.setDate(today.getDate() - 1);
                    break;
                case '7days':
                    startDate.setDate(today.getDate() - 7);
                    break;
                case '30days':
                    startDate.setDate(today.getDate() - 30);
                    break;
                case '90days':
                    startDate.setDate(today.getDate() - 90);
                    break;
                case 'custom':
                    const customStart = document.getElementById('customStartDate').value;
                    const customEnd = document.getElementById('customEndDate').value;
                    if (customStart && customEnd) {
                        return {
                            start: new Date(customStart),
                            end: new Date(customEnd)
                        };
                    }
                    startDate.setDate(today.getDate() - 7);
                    break;
                default:
                    startDate.setDate(today.getDate() - 7);
            }
            
            return {
                start: startDate,
                end: today
            };
        }
        
        // Format date for display
        function formatDateForDisplay(date) {
            return date.toISOString().split('T')[0];
        }
        
        // Load analytics statistics
        async function loadAnalyticsStats() {
            try {
                const dateRange = getDateRange();
                const startStr = formatDateForDisplay(dateRange.start);
                const endStr = formatDateForDisplay(dateRange.end);
                
                console.log('Loading analytics stats from', startStr, 'to', endStr);
                
                // First, try to load from analytics_daily_stats table
                let { data: dailyStats, error: statsError } = await state.db
                    .from('analytics_daily_stats')
                    .select('*')
                    .gte('date', startStr)
                    .lte('date', endStr)
                    .order('date', { ascending: true });
                
                console.log('Daily stats from analytics_daily_stats:', { dailyStats, statsError });
                
                // If analytics_daily_stats doesn't exist or has no data, calculate from sessions
                if (statsError || !dailyStats || dailyStats.length === 0) {
                    console.log('No analytics_daily_stats data, calculating from sessions...');
                    
                    // Get sessions data for the date range
                    const { data: sessions, error: sessionsError } = await state.db
                        .from('analytics_sessions')
                        .select('*')
                        .gte('created_at', startStr)
                        .lte('created_at', endStr);
                    
                    console.log('Sessions data for stats:', { sessions, sessionsError });
                    
                    if (sessionsError || !sessions) {
                        console.log('No sessions data available');
                        return;
                    }
                    
                    // Calculate basic stats from sessions
                    const totalVisitors = sessions.length;
                    const totalSessions = sessions.length;
                    const newVisitors = sessions.filter(s => s.is_first_visit).length;
                    const returningVisitors = totalVisitors - newVisitors;
                    
                    // Get pageviews
                    const { data: pageviews, error: pageviewsError } = await state.db
                        .from('analytics_pageviews')
                        .select('*')
                        .gte('created_at', startStr)
                        .lte('created_at', endStr);
                    
                    const totalPageviews = pageviews && !pageviewsError ? pageviews.length : 0;
                    
                    // Get conversions
                    const { data: conversions, error: conversionsError } = await state.db
                        .from('analytics_conversions')
                        .select('*')
                        .gte('created_at', startStr)
                        .lte('created_at', endStr);
                    
                    const totalConversions = conversions && !conversionsError ? conversions.length : 0;
                    
                    // Calculate session durations
                    const validDurations = sessions.filter(s => s.session_duration && s.session_duration > 0)
                        .map(s => s.session_duration);
                    const avgSessionDuration = validDurations.length > 0 
                        ? validDurations.reduce((a, b) => a + b, 0) / validDurations.length 
                        : 0;
                    
                    // Estimate bounce rate (sessions with only 1 pageview)
                    const bounceCount = sessions.filter(s => s.pageviews_count <= 1).length;
                    const bounceRate = totalSessions > 0 ? (bounceCount / totalSessions) * 100 : 0;
                    
                    // Calculate conversion rate
                    const conversionRate = totalSessions > 0 ? (totalConversions / totalSessions) * 100 : 0;
                    
                    // Update UI with calculated stats
                    document.getElementById('totalVisitors').textContent = totalVisitors.toLocaleString();
                    document.getElementById('totalPageviews').textContent = totalPageviews.toLocaleString();
                    document.getElementById('totalConversions').textContent = totalConversions.toLocaleString();
                    document.getElementById('conversionRate').textContent = conversionRate.toFixed(1) + '%';
                    document.getElementById('avgSessionDuration').textContent = formatDuration(avgSessionDuration);
                    document.getElementById('bounceRate').textContent = bounceRate.toFixed(1) + '%';
                    
                    // For demo purposes, set some placeholder values
                    document.getElementById('revenueGenerated').textContent = '' + (totalConversions * 100).toFixed(0);
                    document.getElementById('avgOrderValue').textContent = '' + (totalConversions > 0 ? 100 : 0).toFixed(2);
                    
                    return;
                }
                
                // If we have daily stats data, use it
                // Calculate totals
                const totals = dailyStats.reduce((acc, day) => {
                    acc.totalVisitors += day.total_visitors || 0;
                    acc.totalSessions += day.total_sessions || 0;
                    acc.totalPageviews += day.total_pageviews || 0;
                    acc.totalConversions += day.total_conversions || 0;
                    acc.totalRevenue += parseFloat(day.revenue_generated) || 0;
                    acc.avgSessionDuration += day.avg_session_duration || 0;
                    acc.bounceRate += day.bounce_rate || 0;
                    return acc;
                }, {
                    totalVisitors: 0,
                    totalSessions: 0,
                    totalPageviews: 0,
                    totalConversions: 0,
                    totalRevenue: 0,
                    avgSessionDuration: 0,
                    bounceRate: 0
                });
                
                // Calculate averages
                const avgSessionDuration = totals.avgSessionDuration / dailyStats.length;
                const avgBounceRate = totals.bounceRate / dailyStats.length;
                const conversionRate = totals.totalSessions > 0 ? (totals.totalConversions / totals.totalSessions) * 100 : 0;
                const avgOrderValue = totals.totalConversions > 0 ? totals.totalRevenue / totals.totalConversions : 0;
                
                // Update UI
                document.getElementById('totalVisitors').textContent = totals.totalVisitors.toLocaleString();
                document.getElementById('totalPageviews').textContent = totals.totalPageviews.toLocaleString();
                document.getElementById('totalConversions').textContent = totals.totalConversions.toLocaleString();
                document.getElementById('conversionRate').textContent = conversionRate.toFixed(1) + '%';
                document.getElementById('avgSessionDuration').textContent = formatDuration(avgSessionDuration);
                document.getElementById('bounceRate').textContent = avgBounceRate.toFixed(1) + '%';
                document.getElementById('revenueGenerated').textContent = '' + totals.totalRevenue.toFixed(0);
                document.getElementById('avgOrderValue').textContent = '' + avgOrderValue.toFixed(2);
                
            } catch (err) {
                console.error('Error loading analytics stats:', err);
            }
        }
        
        // Format duration from seconds
        function formatDuration(seconds) {
            if (!seconds || seconds === 0) return '0s';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
        }
        
        // Load traffic chart
        async function loadTrafficChart() {
            try {
                const dateRange = getDateRange();
                const startStr = formatDateForDisplay(dateRange.start);
                const endStr = formatDateForDisplay(dateRange.end);
                
                console.log('Loading traffic chart data from', startStr, 'to', endStr);
                
                // First try to get data from analytics_daily_stats
                let { data: dailyStats, error } = await state.db
                    .from('analytics_daily_stats')
                    .select('date, total_visitors, total_pageviews, total_sessions')
                    .gte('date', startStr)
                    .lte('date', endStr)
                    .order('date', { ascending: true });
                
                console.log('Traffic chart data from analytics_daily_stats:', { dailyStats, error });
                
                // If no daily stats, generate from sessions data
                if (error || !dailyStats || dailyStats.length === 0) {
                    console.log('Generating chart data from sessions...');
                    
                    // Get sessions grouped by date
                    const { data: sessions, error: sessionsError } = await state.db
                        .from('analytics_sessions')
                        .select('created_at')
                        .gte('created_at', startStr)
                        .lte('created_at', endStr);
                    
                    if (sessionsError || !sessions) {
                        createEmptyChart('trafficChart', 'No traffic data available');
                        return;
                    }
                    
                    // Group sessions by date
                    const sessionsByDate = {};
                    sessions.forEach(session => {
                        const date = new Date(session.created_at).toISOString().split('T')[0];
                        if (!sessionsByDate[date]) {
                            sessionsByDate[date] = 0;
                        }
                        sessionsByDate[date]++;
                    });
                    
                    // Get pageviews by date
                    const { data: pageviews, error: pageviewsError } = await state.db
                        .from('analytics_pageviews')
                        .select('created_at')
                        .gte('created_at', startStr)
                        .lte('created_at', endStr);
                    
                    const pageviewsByDate = {};
                    if (pageviews && !pageviewsError) {
                        pageviews.forEach(pageview => {
                            const date = new Date(pageview.created_at).toISOString().split('T')[0];
                            if (!pageviewsByDate[date]) {
                                pageviewsByDate[date] = 0;
                            }
                            pageviewsByDate[date]++;
                        });
                    }
                    
                    // Create daily stats array
                    const dates = [];
                    const visitorsData = [];
                    const pageviewsData = [];
                    const sessionsData = [];
                    
                    // Generate all dates in range
                    const currentDate = new Date(dateRange.start);
                    while (currentDate <= dateRange.end) {
                        const dateStr = currentDate.toISOString().split('T')[0];
                        const displayDate = currentDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        
                        dates.push(displayDate);
                        visitorsData.push(sessionsByDate[dateStr] || 0);
                        pageviewsData.push(pageviewsByDate[dateStr] || 0);
                        sessionsData.push(sessionsByDate[dateStr] || 0);
                        
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    
                    dailyStats = dates.map((date, index) => ({
                        date: date,
                        total_visitors: visitorsData[index],
                        total_pageviews: pageviewsData[index],
                        total_sessions: sessionsData[index]
                    }));
                }
                
                if (!dailyStats || dailyStats.length === 0) {
                    createEmptyChart('trafficChart', 'No traffic data available');
                    return;
                }
                
                const dates = dailyStats.map(day => {
                    // Handle both date string formats
                    if (typeof day.date === 'string') {
                        const date = new Date(day.date);
                        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    }
                    return day.date;
                });
                
                const visitors = dailyStats.map(day => day.total_visitors || 0);
                const pageviews = dailyStats.map(day => day.total_pageviews || 0);
                const sessions = dailyStats.map(day => day.total_sessions || 0);
                
                const ctx = document.getElementById('trafficChart').getContext('2d');
                
                // Destroy existing chart if it exists
                if (state.analyticsCharts.traffic) {
                    state.analyticsCharts.traffic.destroy();
                }
                
                state.analyticsCharts.traffic = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Visitors',
                                data: visitors,
                                borderColor: '#3B82F6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            },
                            {
                                label: 'Pageviews',
                                data: pageviews,
                                borderColor: '#10B981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            },
                            {
                                label: 'Sessions',
                                data: sessions,
                                borderColor: '#8B5CF6',
                                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        if (value >= 1000) {
                                            return (value / 1000).toFixed(1) + 'k';
                                        }
                                        return value;
                                    }
                                }
                            }
                        }
                    }
                });
                
            } catch (err) {
                console.error('Error loading traffic chart:', err);
                createEmptyChart('trafficChart', 'Error loading traffic data');
            }
        }
        
        // Load sources chart
        async function loadSourcesChart() {
            try {
                const dateRange = getDateRange();
                const startStr = formatDateForDisplay(dateRange.start);
                const endStr = formatDateForDisplay(dateRange.end);
                
                console.log('Loading sources chart data from', startStr, 'to', endStr);
                
                // Try to get data from analytics_daily_stats first
                let { data: dailyStats, error } = await state.db
                    .from('analytics_daily_stats')
                    .select('organic_search, direct_traffic, social_media, referral_traffic, email_campaigns')
                    .gte('date', startStr)
                    .lte('date', endStr);
                
                console.log('Sources data from analytics_daily_stats:', { dailyStats, error });
                
                // If no daily stats, try to calculate from sessions
                if (error || !dailyStats || dailyStats.length === 0) {
                    console.log('Calculating sources from sessions data...');
                    
                    // Get sessions with utm_source
                    const { data: sessions, error: sessionsError } = await state.db
                        .from('analytics_sessions')
                        .select('utm_source')
                        .gte('created_at', startStr)
                        .lte('created_at', endStr);
                    
                    if (sessionsError || !sessions) {
                        createEmptyChart('sourcesChart', 'No traffic sources data');
                        return;
                    }
                    
                    // Count sources
                    const sourceCounts = {
                        organic: 0,
                        direct: 0,
                        social: 0,
                        referral: 0,
                        email: 0
                    };
                    
                    sessions.forEach(session => {
                        const source = (session.utm_source || '').toLowerCase();
                        if (source.includes('google') || source.includes('bing') || source.includes('yahoo')) {
                            sourceCounts.organic++;
                        } else if (source.includes('facebook') || source.includes('twitter') || source.includes('instagram')) {
                            sourceCounts.social++;
                        } else if (source.includes('email') || source.includes('newsletter')) {
                            sourceCounts.email++;
                        } else if (source && source !== 'direct') {
                            sourceCounts.referral++;
                        } else {
                            sourceCounts.direct++;
                        }
                    });
                    
                    // Create dummy daily stats
                    dailyStats = [{
                        organic_search: sourceCounts.organic,
                        direct_traffic: sourceCounts.direct,
                        social_media: sourceCounts.social,
                        referral_traffic: sourceCounts.referral,
                        email_campaigns: sourceCounts.email
                    }];
                }
                
                // Calculate totals
                const totals = dailyStats.reduce((acc, day) => {
                    acc.organic += day.organic_search || 0;
                    acc.direct += day.direct_traffic || 0;
                    acc.social += day.social_media || 0;
                    acc.referral += day.referral_traffic || 0;
                    acc.email += day.email_campaigns || 0;
                    return acc;
                }, { organic: 0, direct: 0, social: 0, referral: 0, email: 0 });
                
                const totalTraffic = totals.organic + totals.direct + totals.social + totals.referral + totals.email;
                
                if (totalTraffic === 0) {
                    createEmptyChart('sourcesChart', 'No traffic data available');
                    return;
                }
                
                const ctx = document.getElementById('sourcesChart').getContext('2d');
                
                // Destroy existing chart if it exists
                if (state.analyticsCharts.sources) {
                    state.analyticsCharts.sources.destroy();
                }
                
                state.analyticsCharts.sources = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Organic Search', 'Direct Traffic', 'Social Media', 'Referral', 'Email'],
                        datasets: [{
                            data: [
                                totals.organic,
                                totals.direct,
                                totals.social,
                                totals.referral,
                                totals.email
                            ],
                            backgroundColor: [
                                'rgba(16, 185, 129, 0.8)',
                                'rgba(59, 130, 246, 0.8)',
                                'rgba(236, 72, 153, 0.8)',
                                'rgba(245, 158, 11, 0.8)',
                                'rgba(139, 92, 246, 0.8)'
                            ],
                            borderColor: [
                                '#10B981',
                                '#3B82F6',
                                '#EC4899',
                                '#F59E0B',
                                '#8B5CF6'
                            ],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.raw;
                                        const percentage = ((value / totalTraffic) * 100).toFixed(1);
                                        return `${context.label}: ${value.toLocaleString()} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
                
            } catch (err) {
                console.error('Error loading sources chart:', err);
                createEmptyChart('sourcesChart', 'Error loading sources data');
            }
        }
        
        // Load device chart
        async function loadDeviceChart() {
            try {
                const dateRange = getDateRange();
                const startStr = formatDateForDisplay(dateRange.start);
                const endStr = formatDateForDisplay(dateRange.end);
                
                console.log('Loading device chart data from', startStr, 'to', endStr);
                
                // Try to get data from analytics_daily_stats first
                let { data: dailyStats, error } = await state.db
                    .from('analytics_daily_stats')
                    .select('mobile_users, desktop_users, tablet_users')
                    .gte('date', startStr)
                    .lte('date', endStr);
                
                console.log('Device data from analytics_daily_stats:', { dailyStats, error });
                
                // If no daily stats, calculate from sessions
                if (error || !dailyStats || dailyStats.length === 0) {
                    console.log('Calculating device data from sessions...');
                    
                    // Get sessions with device_type
                    const { data: sessions, error: sessionsError } = await state.db
                        .from('analytics_sessions')
                        .select('device_type')
                        .gte('created_at', startStr)
                        .lte('created_at', endStr);
                    
                    if (sessionsError || !sessions) {
                        createEmptyChart('deviceChart', 'No device data available');
                        return;
                    }
                    
                    // Count devices
                    const deviceCounts = {
                        mobile: 0,
                        desktop: 0,
                        tablet: 0
                    };
                    
                    sessions.forEach(session => {
                        const device = (session.device_type || '').toLowerCase();
                        if (device.includes('mobile') || device.includes('android') || device.includes('iphone')) {
                            deviceCounts.mobile++;
                        } else if (device.includes('tablet') || device.includes('ipad')) {
                            deviceCounts.tablet++;
                        } else {
                            deviceCounts.desktop++;
                        }
                    });
                    
                    // Create dummy daily stats
                    dailyStats = [{
                        mobile_users: deviceCounts.mobile,
                        desktop_users: deviceCounts.desktop,
                        tablet_users: deviceCounts.tablet
                    }];
                }
                
                // Calculate totals
                const totals = dailyStats.reduce((acc, day) => {
                    acc.mobile += day.mobile_users || 0;
                    acc.desktop += day.desktop_users || 0;
                    acc.tablet += day.tablet_users || 0;
                    return acc;
                }, { mobile: 0, desktop: 0, tablet: 0 });
                
                const totalDevices = totals.mobile + totals.desktop + totals.tablet;
                
                if (totalDevices === 0) {
                    createEmptyChart('deviceChart', 'No device data available');
                    return;
                }
                
                const ctx = document.getElementById('deviceChart').getContext('2d');
                
                // Destroy existing chart if it exists
                if (state.analyticsCharts.devices) {
                    state.analyticsCharts.devices.destroy();
                }
                
                state.analyticsCharts.devices = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: ['Mobile', 'Desktop', 'Tablet'],
                        datasets: [{
                            data: [totals.mobile, totals.desktop, totals.tablet],
                            backgroundColor: [
                                'rgba(59, 130, 246, 0.8)',
                                'rgba(16, 185, 129, 0.8)',
                                'rgba(139, 92, 246, 0.8)'
                            ],
                            borderColor: [
                                '#3B82F6',
                                '#10B981',
                                '#8B5CF6'
                            ],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.raw;
                                        const percentage = ((value / totalDevices) * 100).toFixed(1);
                                        return `${context.label}: ${value.toLocaleString()} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
                
            } catch (err) {
                console.error('Error loading device chart:', err);
                createEmptyChart('deviceChart', 'Error loading device data');
            }
        }
        
        // Load active users
        async function loadActiveUsers() {
            try {
                const container = document.getElementById('activeUsersList');
                const now = new Date();
                const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
                
                console.log('Loading active users since', fiveMinutesAgo.toISOString());
                
                // First try analytics_active_users table
                let { data: activeUsers, error } = await state.db
                    .from('analytics_active_users')
                    .select('*')
                    .gte('last_activity', fiveMinutesAgo.toISOString())
                    .order('last_activity', { ascending: false })
                    .limit(20);
                
                console.log('Active users from analytics_active_users:', { activeUsers, error });
                
                // If analytics_active_users doesn't exist or has no data, show placeholder
                if (error || !activeUsers) {
                    console.log('No analytics_active_users table, showing placeholder');
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--medium-gray);">Active users tracking requires analytics_active_users table</div>';
                    document.getElementById('activeUsersCount').textContent = '0';
                    return;
                }
                
                // Update count
                document.getElementById('activeUsersCount').textContent = activeUsers.length;
                
                if (activeUsers.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--medium-gray);">No users active right now</div>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
                
                activeUsers.forEach(user => {
                    const lastActive = new Date(user.last_activity);
                    const timeAgo = Math.floor((now - lastActive) / 1000);
                    const minutesAgo = Math.floor(timeAgo / 60);
                    
                    html += `
                        <div class="active-user-item">
                            <div class="active-user-avatar">
                                ${user.city ? user.city.charAt(0).toUpperCase() : 'U'}
                            </div>
                            <div class="active-user-info">
                                <div style="font-weight: 600; color: var(--dark-gray); font-size: 13px;">
                                    ${user.city || 'Unknown location'}
                                </div>
                                <div class="active-user-location">
                                    ${user.current_action || 'Browsing'}  ${user.is_mobile ? 'Mobile' : 'Desktop'}
                                </div>
                            </div>
                            <div class="active-user-time">
                                ${minutesAgo === 0 ? 'Just now' : `${minutesAgo}m ago`}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (err) {
                console.error('Error loading active users:', err);
                document.getElementById('activeUsersList').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--red);">Error loading active users</div>';
                document.getElementById('activeUsersCount').textContent = '0';
            }
        }
        
        // Load search terms
        async function loadSearchTerms() {
            try {
                const container = document.getElementById('searchTermsList');
                
                console.log('Loading search terms...');
                
                const { data: searchTerms, error } = await state.db
                    .from('analytics_search_terms')
                    .select('*')
                    .order('search_count', { ascending: false })
                    .limit(10);
                
                console.log('Search terms data:', { searchTerms, error });
                
                if (error || !searchTerms || searchTerms.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--medium-gray);">No search terms data</div>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
                
                searchTerms.forEach(term => {
                    html += `
                        <div class="search-term-item ${term.is_in_coverage_area ? 'in-coverage' : 'out-coverage'}">
                            <div class="search-term-text" title="${term.search_term}">
                                ${term.search_term.length > 30 ? term.search_term.substring(0, 30) + '...' : term.search_term}
                            </div>
                            <div class="search-term-count">
                                ${term.search_count}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (err) {
                console.error('Error loading search terms:', err);
                document.getElementById('searchTermsList').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--red);">Error loading search terms</div>';
            }
        }
        
        // Load sessions
        async function loadSessions() {
            try {
                const container = document.getElementById('sessionsList');
                const dateRange = getDateRange();
                const startStr = formatDateForDisplay(dateRange.start);
                const endStr = formatDateForDisplay(dateRange.end);
                
                console.log('Loading sessions from', startStr, 'to', endStr);
                
                const { data: sessions, error } = await state.db
                    .from('analytics_sessions')
                    .select('*')
                    .gte('created_at', startStr)
                    .lte('created_at', endStr)
                    .order('created_at', { ascending: false })
                    .limit(15);
                
                console.log('Sessions data:', { sessions, error });
                
                if (error || !sessions || sessions.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--medium-gray);">No sessions data available</div>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
                
                sessions.forEach(session => {
                    const created = new Date(session.created_at);
                    const timeStr = created.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                    
                    html += `
                        <div class="session-item">
                            <div class="session-header">
                                <div class="session-id" title="${session.session_id}">
                                    ${session.session_id ? session.session_id.substring(0, 8) + '...' : 'Unknown'}
                                </div>
                                ${session.is_converted ? `
                                    <div class="session-converted">
                                        <i class="fas fa-check-circle"></i> Converted
                                    </div>
                                ` : ''}
                            </div>
                            
                            <div class="session-details">
                                <div class="session-detail">
                                    <div class="session-label">Device</div>
                                    <div class="session-value">${session.device_type || 'Unknown'}</div>
                                </div>
                                
                                <div class="session-detail">
                                    <div class="session-label">Location</div>
                                    <div class="session-value">${session.city || session.region || session.country || 'Unknown'}</div>
                                </div>
                                
                                <div class="session-detail">
                                    <div class="session-label">Source</div>
                                    <div class="session-value">${session.utm_source || 'Direct'}</div>
                                </div>
                                
                                <div class="session-detail">
                                    <div class="session-label">Time</div>
                                    <div class="session-value">${timeStr}</div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (err) {
                console.error('Error loading sessions:', err);
                document.getElementById('sessionsList').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--red);">Error loading sessions</div>';
            }
        }
        
        // Load recent conversions
        async function loadRecentConversions() {
            try {
                const container = document.getElementById('recentConversions');
                const dateRange = getDateRange();
                const startStr = formatDateForDisplay(dateRange.start);
                const endStr = formatDateForDisplay(dateRange.end);
                
                console.log('Loading conversions from', startStr, 'to', endStr);
                
                const { data: conversions, error } = await state.db
                    .from('analytics_conversions')
                    .select('*')
                    .gte('created_at', startStr)
                    .lte('created_at', endStr)
                    .order('created_at', { ascending: false })
                    .limit(10);
                
                console.log('Conversions data:', { conversions, error });
                
                if (error || !conversions || conversions.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--medium-gray);">No conversion data available</div>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
                
                conversions.forEach(conversion => {
                    const date = new Date(conversion.created_at);
                    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    const timeStr = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                    
                    html += `
                        <div style="padding: 12px; background: #f9fafb; border-radius: 8px; border-left: 4px solid var(--primary-green);">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 5px;">
                                <div style="font-weight: 700; color: var(--dark-gray); font-size: 14px;">
                                    ${conversion.conversion_type || 'Conversion'}
                                </div>
                                <div style="font-size: 11px; color: var(--medium-gray);">
                                    ${dateStr} ${timeStr}
                                </div>
                            </div>
                            <div style="font-size: 12px; color: var(--dark-gray); margin-bottom: 5px;">
                                ${conversion.customer_email || conversion.customer_phone || 'Anonymous'}
                            </div>
                            ${conversion.conversion_value ? `
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div style="font-size: 11px; color: var(--medium-gray);">
                                        Value
                                    </div>
                                    <div style="font-weight: 700; color: var(--primary-green); font-size: 14px;">
                                        ${parseFloat(conversion.conversion_value).toFixed(2)}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (err) {
                console.error('Error loading recent conversions:', err);
                document.getElementById('recentConversions').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--red);">Error loading conversions</div>';
            }
        }
        
        // Load geographic data
        async function loadGeoData() {
            try {
                const container = document.getElementById('geoData');
                const dateRange = getDateRange();
                const startStr = formatDateForDisplay(dateRange.start);
                const endStr = formatDateForDisplay(dateRange.end);
                
                console.log('Loading geo data from', startStr, 'to', endStr);
                
                const { data: sessions, error } = await state.db
                    .from('analytics_sessions')
                    .select('city, region, country')
                    .not('city', 'is', null)
                    .gte('created_at', startStr)
                    .lte('created_at', endStr)
                    .limit(50);
                
                console.log('Geo data:', { sessions, error });
                
                if (error || !sessions || sessions.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--medium-gray);">No geographic data available</div>';
                    return;
                }
                
                // Count locations
                const locations = {};
                sessions.forEach(session => {
                    const key = session.city || session.region || session.country || 'Unknown';
                    locations[key] = (locations[key] || 0) + 1;
                });
                
                // Convert to array and sort
                const topLocations = Object.entries(locations)
                    .map(([location, count]) => ({ location, count }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 8);
                
                let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
                
                topLocations.forEach(loc => {
                    const percentage = (loc.count / sessions.length * 100).toFixed(1);
                    
                    html += `
                        <div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <div style="font-weight: 600; color: var(--dark-gray); font-size: 13px;">
                                    ${loc.location}
                                </div>
                                <div style="font-weight: 700; color: var(--primary-green); font-size: 13px;">
                                    ${loc.count}
                                </div>
                            </div>
                            <div style="height: 6px; background: #e5e7eb; border-radius: 3px; overflow: hidden;">
                                <div style="height: 100%; background: var(--primary-green); width: ${percentage}%; border-radius: 3px;"></div>
                            </div>
                            <div style="font-size: 11px; color: var(--medium-gray); margin-top: 3px;">
                                ${percentage}% of traffic
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (err) {
                console.error('Error loading geographic data:', err);
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--red);">Error loading geographic data</div>';
            }
        }
        
        // Create empty chart placeholder
        function createEmptyChart(canvasId, message) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            // Destroy existing chart if it exists
            if (state.analyticsCharts[canvasId]) {
                state.analyticsCharts[canvasId].destroy();
            }
            
            state.analyticsCharts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: message,
                            color: '#9CA3AF',
                            font: {
                                size: 14
                            }
                        }
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    }
                }
            });
        }
        
        // Handle date range change
        function handleDateRangeChange() {
            const value = document.getElementById('analyticsDateRange').value;
            state.analyticsDateRange = value;
            
            if (value === 'custom') {
                document.getElementById('customDateRange').style.display = 'block';
                
                // Set default custom dates (last 7 days)
                const today = new Date();
                const lastWeek = new Date();
                lastWeek.setDate(today.getDate() - 7);
                
                document.getElementById('customStartDate').value = lastWeek.toISOString().split('T')[0];
                document.getElementById('customEndDate').value = today.toISOString().split('T')[0];
            } else {
                document.getElementById('customDateRange').style.display = 'none';
                loadAnalytics();
            }
        }
        
        // Apply custom date range
        function applyCustomDateRange() {
            const startDate = document.getElementById('customStartDate').value;
            const endDate = document.getElementById('customEndDate').value;
            
            if (!startDate || !endDate) {
                showNotification('Please select both start and end dates', 'warning');
                return;
            }
            
            if (new Date(startDate) > new Date(endDate)) {
                showNotification('Start date must be before end date', 'warning');
                return;
            }
            
            loadAnalytics();
        }
        
        // Cancel custom date range
        function cancelCustomDateRange() {
            document.getElementById('analyticsDateRange').value = '7days';
            document.getElementById('customDateRange').style.display = 'none';
            state.analyticsDateRange = '7days';
            loadAnalytics();
        }
        
        // Update chart type
        function updateChartType(chartType) {
            // Update button states
            document.querySelectorAll('[data-chart]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-chart="${chartType}"]`).classList.add('active');
            
            // In a real app, you would update the chart data here
            // For now, just reload the traffic chart
            loadTrafficChart();
        }
        
        // Export analytics data
        async function exportAnalytics() {
            try {
                const dateRange = getDateRange();
                const startStr = formatDateForDisplay(dateRange.start);
                const endStr = formatDateForDisplay(dateRange.end);
                
                const { data: dailyStats, error } = await state.db
                    .from('analytics_daily_stats')
                    .select('*')
                    .gte('date', startStr)
                    .lte('date', endStr)
                    .order('date', { ascending: true });
                
                if (error || !dailyStats || dailyStats.length === 0) {
                    showNotification('No analytics data to export', 'warning');
                    return;
                }
                
                // Convert to CSV
                const headers = Object.keys(dailyStats[0]).join(',');
                const rows = dailyStats.map(day => 
                    Object.values(day).map(value => 
                        typeof value === 'string' ? `"${value.replace(/"/g, '""')}"` : value
                    ).join(',')
                );
                
                const csvContent = [headers, ...rows].join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `greenglo-analytics-${startStr}-to-${endStr}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                showNotification('Analytics data exported successfully!', 'success');
                
            } catch (err) {
                console.error('Error exporting analytics:', err);
                showNotification('Error exporting analytics data: ' + err.message, 'error');
            }
        }
        
        // Export specific data type
        async function exportData(dataType) {
            try {
                const dateRange = getDateRange();
                const startStr = formatDateForDisplay(dateRange.start);
                const endStr = formatDateForDisplay(dateRange.end);
                
                let tableName;
                switch(dataType) {
                    case 'sessions':
                        tableName = 'analytics_sessions';
                        break;
                    case 'conversions':
                        tableName = 'analytics_conversions';
                        break;
                    case 'pageviews':
                        tableName = 'analytics_pageviews';
                        break;
                    case 'search_terms':
                        tableName = 'analytics_search_terms';
                        break;
                    default:
                        throw new Error('Invalid data type');
                }
                
                const { data: records, error } = await state.db
                    .from(tableName)
                    .select('*')
                    .gte('created_at', startStr)
                    .lte('created_at', endStr)
                    .order('created_at', { ascending: true });
                
                if (error || !records || records.length === 0) {
                    showNotification(`No ${dataType} data to export`, 'warning');
                    return;
                }
                
                // Convert to CSV
                const headers = Object.keys(records[0]).join(',');
                const rows = records.map(record => 
                    Object.values(record).map(value => {
                        if (value === null || value === undefined) return '';
                        if (typeof value === 'object') return `"${JSON.stringify(value).replace(/"/g, '""')}"`;
                        if (typeof value === 'string') return `"${value.replace(/"/g, '""')}"`;
                        return value;
                    }).join(',')
                );
                
                const csvContent = [headers, ...rows].join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `greenglo-${dataType}-${startStr}-to-${endStr}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                showNotification(`${dataType} data exported successfully!`, 'success');
                
            } catch (err) {
                console.error(`Error exporting ${dataType}:`, err);
                showNotification(`Error exporting ${dataType} data: ${err.message}`, 'error');
            }
        }
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
        
        // Clean up on page unload
        window.addEventListener('beforeunload', stopActiveUsersPolling);
        
        // Expose some functions globally for onclick handlers
        window.apply247ToSelectedDay = apply247ToSelectedDay;
        window.loadTimeSlots = loadTimeSlots;
        window.showSection = showSection;
        window.openDatabaseSetupModal = openDatabaseSetupModal;
        window.closeDatabaseSetupModal = closeDatabaseSetupModal;
        window.copyToClipboard = copyToClipboard;
        window.updateBookingStatus = updateBookingStatus;
        window.apply247Bulk = apply247Bulk;
        window.closeBulkSetupModal = closeBulkSetupModal;
        window.openBulkSetupModal = openBulkSetupModal;
        window.loadAnalytics = loadAnalytics;
        window.exportAnalytics = exportAnalytics;
        window.exportData = exportData;
        
    })();
</script>
